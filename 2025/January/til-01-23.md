# 프론트엔드 면접 질문 (자바스크립트)

## `(1) this에 대해 설명해주세요.`

this는 javascript에서 함수가 호출되는 문맥에 따라 달라지는 키워드입니다.

- 전역에서는 전역 객체를 가리키고(window 또는 global)
- 메서드에서는 호출한 객체
- 생성자 함수에서는 새로 생성된 인스턴스를 가리킵니다

또한, 화살표 함수는 상위 스코프의 this를 상속 받으며, bind, call, aplly로 this를 명시적으로 변경할 수 있습니다.

## `(2) 콜백 함수에 대해 설명해주세요.`

콜백 함수는 다른 함수에 인자로 전달되어 특정 작업이 완료된 후 실행되는 함수입니다.
주로 비동기 작업이나 이벤트 처리에서 사용되며, 예를 들어 setTimeout이나 배열 메서드(forEach, map)등에서도 활용됩니다.

`javascript의 비동기 처리 이해`

- javascript는 싱글 스레드 기반 언어
- 비동기 처리를 위해 이벤트 루프와 콜백을 활용

### `콜백 지옥을 해결하는 방법`

콜백 지옥은 중첩된 콜백 함수가 많아져서 코드가 복잡하고 가독성이 떨어지는 문제이다.

- Named Function 사용: 익명 함수 대신 이름이 있는 함수로 분리하여 가독성을 높인다.
- Promise 사용: Promise는 콜백의 중첩을 줄이고 .then 체이닝으로 가독성을 높여준다.
- async/await 사용: async/await는 Promise를 더 직관적으로 다룰 수 있도록 해준다. 비동기 코드를 동기식 코드처럼 작성할 수 있다.
- Promise.all 사용: 여러 비동기 작업을 병렬로 처리(여러 작업을 동시에 실행하는 방식)해야 할 때 Promise.all로 효율적으로 관리할 수 있다.
- 비동기 라이브러리 사용: async 같은 외부 라이브러리를 사용해 비동기 작업을 더 체계적으로 관리할 수 있다.

콜백 지옥은 중첩된 콜백으로 인해 가독성이 떨어지는 문제입니다. 이를 해결하기 위해 Named Function로 분리하거나, Promise와 async/await를 사용하여 코드 흐름을 간단하고 직관적으로 바꿀 수 있습니다.

## `(3) Promise와 Callback를 비교 설명해주세요.`

Promise와 Callback은 둘 다 javascript에서 비동기 작업을 처리하기 위한 방법입니다.Callback은 함수 인자로 전달되어 작업 완료 후 실행되지만, 중첩 시 가독성이 떨어지고 에러처리가 어렵다는 단점이 있습니다. 반면 Promise는 상태를 관리하며 체이닝(then, catch)으로 가독성을 높이고, 병렬 작업 관리도 간단히 처리할 수 있습니다.

## `(4) Async, Await이 뭔지 그리고 사용 방법을 설명해주세요.`

async/await는 javascript에서 **Promise기반 비동기 코드를 더 간결하고 직관적으로 작성할 수 있도록 도와주는 문법**입니다. ES8에서 도입되었으며, 비동기 작업을 마치 동기 코드처럼 작성할 수 있게 해줍니다.

- `async`: 함수 앞에 붙여서 해당 함수가 항상 Promise를 반환하도록 만듭니다. 함수 내부에서 await를 사용할 수 있습니다.
- `await`: Promise가 해결될 때까지 기다린 후, 결과 값을 반환합니다. await은 반드시 async 함수 안에서만 사용할 수 있습니다.

## `(5) 동기와 비동기`

동기와 비동기는 작업이 처리되는 방식에 대한 개념이다.

`동기(Synchronous)란?`

- 작업이 순서대로 실행.
- 하나의 작업이 끝나야 다음 작업이 실행됨.
- 결과가 나올 때까지 기다린다.
- 시간이 오래 걸리는 작업(예: 파일 읽기, 네트워크 요청)이 있을 경우, 프로그램이 멈춘 상태로 기다려야 하므로 효율성이 떨어질 수 있음.

`비동기(Asynchronous)란?`

- 작업을 시작한 후 기다리지 않고 다음 작업으로 넘어간다.
- 작업이 끝나는 시점에 콜백 함수나 Promise를 통해 결과를 처리한다.
- javascript에서는 비동기 처리를 통해 프로그램의 응답성을 높일 수 있다.

javascript는 기본적으로 싱글 스레드로 동작합니다. 즉, 한 번에 한 가지 작업만 처리할 수 있습니다. 하지만 비동기 처리(콜백, Promise, async/await)를 사용하면 시간이 오래 걸리는 작업을 다른 작업과 동시에 효율적으로 처리할 수 있습니다.

## `(6) var, let, const 차이를 설명해주세요`

var, let, const는 javascript에서 변수를 선언할 때 사용하는 키워드입니다.
각각의 키워드는 변수의 스코프, 재할당 가능성, 호이스팅 동작 방식에서 차이가 있습니다.
|특징|var|let|const|
|---|---|---|---|
|스코프|함수 스코프|블록 스코프|블록 스코프|
|재선언 가능 여부|가능|불가능|불가능|
|재할당 가능 여부|가능|가능|불가능|
|초기화 여부|선언만 하고 초기화하지 않아도 사용 가능|선언만 하면 undefined, 초기화 필요|선언과 동시에 초기화 필수|
|호이스팅|호이스팅되지만 초기화 없이 undefined로 사용 가능|호이스팅되지만 Temporal Dead Zone(TDZ)에 의해 초기화 전 접근 불가|호이스팅되지만 Temporal Dead Zone(TDZ)에 의해 초기화 전 접근 불가|

### `var`

- 함수 스코프: 변수가 선언된 함수 내부에서만 접근 가능. 하지만 블록(if, for)내부에 선언해도 블록을 무시하고 함수 전체에서 접근 가능.
- 재선언: 같은 이름으로 여러 번 선언 가능.
- 호이스팅: 선언이 변수의 선언 단계만 끌어올려지며, 초기화는 나중에 이루어짐. 따라서 초기화 전에 접근하면 undefined가 반환된다.

```javascript
if (true) {
  var x = 10;
}
console.log(x); // 10(블록 스코프가 적용되지 않음)

console.log(y); //undefined (호이스팅)
var y = 5;
```

### `let`

- 블록 스코프: 변수가 선언된 블록 내부에서만 접근 가능.
- 재선언 불가: 같은 이름으로 다시 선언할 수 없음.
- 호이스팅: 선언은 끌어올려지지만 초기화는 선언 이후에 이루어지므로, 초기화 전에 접근하면 ReferenceError가 발생한다.

```javascript
if (true) {
  let x = 10;
}
console.log(x); // ReferenceError (블록 스코프 적용)

console.log(y); // ReferenceError (TDZ: 초기화 전에 접근 불가)
let y = 5;
```

### `const`

- 블록 스코프: let과 동일하게 블록 내부에서만 접근 가능.
- 재선언 및 재할당 불가: 선언한 변수의 값을 변경할 수 없음.(단 객체나 배열의 경우 내부 값은 수정 가능)
- 호이스팅: let과 동일하게 초기화 전 접근 시 ReferenceError 발생.

```javascript
const x = 10;
x = 20; // TypeError (재할당 불가)

const obj = { key: "value" };
obj.key = "newValue"; // (객체의 속성 수정은 허용)

const arr = [1, 2, 3];
arr.push(4); // (배열의 요소 추가 허용)
```

1. 재할당이 필요 없는 경우: const 사용
2. 재할당이 필요한 경우: let 사용
3. var는 사용하지 않는 것을 권장: 스코프 문제와 호이스팅으로 인한 예측 불가능한 동작을 방지하기 위함.

## `(7) 이벤트 버블링과 캡처링에 대해 설명해주세요`

DOM에서 이벤트가 발생랬을 때 이벤트가 전파되는 순서를 설명하는 두 가지 방식.

### 이벤트 버블링 (Event Bubbling)

- 이벤트가 가장 깊은 자식 요소에서 발생하여 부모 요소를 거쳐 최상위 부모로 전파되는 방식.
  기본적으로 대부분의 이벤트는 버블링 방식으로 동작한다.
- 순서: 이벤트가 **자식 요소에서 부모 요소로 올라가며 전파**된다.

### 이벤트 캡처링 (Event Capturing)

- 이벤트가 최상위 부모에서 시작하여 자식 요소로 전파되는 방식. 캡처링은 기본적으로 비활성화되어 있으며, 이벤트 리스너를 설정할 때 특별히 설정해야 한다.
- 순서: 이벤트가 **부모 요소에서 자식 요소로 내려가며 전파**된다.

```javascript
// 버블링(기본 동작)
element.addEventListener("click", handler);

// 캡처링
element.addEventListener("click", handler, true);
```

이벤트가 버블링 또는 캡처링 단계에서 전파되는 것을 중단하려면
event.stopPropagation()을 사용.

### `이벤트 위임`

이벤트 위임(Event Delegation)은 부모 요소에 이벤트 리스너를 등록하고, 자식 요소에서 발생한 이벤트를 부모 요소에 처리하는 기법이다. 이를 통해 여러 자식 요소에 각각 이벤트 리스너를 설정하는 대신, 하나의 부모 요소에서 모든 이벤트를 처리할 수 있어 성능을 향상시키고, 동적으로 추가된 자식 요소에도 자동으로 이벤트가 적용되므로 유용하다. event.target을 사용하여 실제 클릭된 자식 요소를 확인하고 이벤트를 처리한다.

## `(8) 호이스팅과 발생하는 이유에 대해 설명해주세요.`

호이스팅은 javascript에서 **변수 선언과 함수 선언이 실행 컨텍스트의 최상단으로 끌어올려지는 현상**을 말한다.

호이스팅이 발생하는 이유는 javascript 동작 방식 때문이다.

## `(9) 클로져(Closure)에 대해 설명해주세요.`

클로저는 javascript에서 함수와 그 함수가 선언된 렉시컬 환경을 함께 기억하는 구조를 말한다.
쉽게 말해 **함수가 자신이 선언될 때의 스코프를 기억해서 외부 함수의 변수에 접근할 수 있는 기능**을 클로저라고 한다.
